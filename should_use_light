#!/bin/sh

# Determines whether the current time falls within a configured light period
# and prints the number of seconds until the next light/dark transition.
# Exits with status 0 during the light period, or 1 during the dark period.

# Current time
current_epoch=$(date +%s)
current_hour=$(date +"%H" | sed 's/^0*//')
current_minute=$(date +"%M" | sed 's/^0*//')
[ "$current_minute" = "" ] && current_minute=0

# Light / dark schedule
light_hour=7
light_minute=0
dark_hour=18
dark_minute=0

# Helper: check if we're in light period
use_light() {
    if [ "$light_hour" -lt "$dark_hour" ]; then
        [ "$current_hour" -gt "$light_hour" ] && [ "$current_hour" -lt "$dark_hour" ] || \
        { [ "$current_hour" -eq "$light_hour" ] && [ "$current_minute" -ge "$light_minute" ]; } || \
        { [ "$current_hour" -eq "$dark_hour" ] && [ "$current_minute" -lt "$dark_minute" ]; }
    else
        [ "$current_hour" -lt "$dark_hour" ] || \
        { [ "$current_hour" -eq "$dark_hour" ] && [ "$current_minute" -lt "$dark_minute" ]; }
    fi
}

# Compute today's transition times
today=$(date +"%Y-%m-%d")
light_epoch=$(date -d "$today $light_hour:$light_minute" +%s)
dark_epoch=$(date -d "$today $dark_hour:$dark_minute" +%s)

if use_light; then
    # Next cycle is dark
    if [ "$current_epoch" -lt "$dark_epoch" ]; then
        next_epoch="$dark_epoch"
    else
        next_epoch=$(date -d "tomorrow $dark_hour:$dark_minute" +%s)
    fi
    echo $((next_epoch - current_epoch))
    exit 0
else
    # Next cycle is light
    if [ "$current_epoch" -lt "$light_epoch" ]; then
        next_epoch="$light_epoch"
    else
        next_epoch=$(date -d "tomorrow $light_hour:$light_minute" +%s)
    fi
    echo $((next_epoch - current_epoch))
    exit 1
fi
