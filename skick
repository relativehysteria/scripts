#!/usr/bin/env python

from __future__ import annotations
from dataclasses import dataclass
from typing import Optional
from datetime import datetime, date
from concurrent.futures import ThreadPoolExecutor
from bs4 import BeautifulSoup
from requests import get

print("This script has been obsoleted by the `bandsintown` script.")

# Concerts in the following locations will be printed in different color
PREFERRED_LOCATIONS = { "Austria", "Czech Republic", "Slovakia", "Germany" }

ARTISTS = {
    "3768296-rum-jungle",
    "590705-bon-iver",
    "4126816-wolf-alice",
    "9329894-queens-pleasure",
    "5806184-jeff-rosenstock",
    "8959074-tamino",
    "605621-tom-rosenthal",
    "10098289-ichiko-aoba",
    "383629-balthazar",
    "496602-sigur-ros",
    "1167694-shakey-graves",
    "590465-olafur-arnalds",
    "715080-warpaint",
    "542593-jose-gonzalez",
    "592267-fleet-foxes",
    "113970-iron-and-wine",
    "7858599-rainbow-kitten-surprise",
    "9582179-momma",
    "9693119-black-country-new-road",
    "9278794-black-midi",
    "10341381-geordie-greep",
    "535518-modest-mouse",
    "118509-sufjan-stevens",
    "277989-sunny-day-real-estate",
    "385433-hum",
    "1706007-pygmy-lush",
    "421785-toe",
    "1667252-enumclaw",
    "10370116-racing-mount-pleasant",
    "8663139-haley-heynderickx",
    "2739046-mouse-on-the-keys",
    "464566-do-make-say-think",
    "9377124-sorry",
    "10234682-new-eves",
    "425997-kilimanjaro-darkjazz-ensemble",
}

BASE_URL = "https://www.songkick.com"

@dataclass
class Concert:
    band: str
    date: date
    venue: str
    location: str

    @staticmethod
    def _get_soup(url: str) -> Optional[BeautifulSoup]:
        headers = { "User-Agent": "Mozilla/5.0 Gecko/20100101 Firefox/145.0" }
        try:
            r = get(url, headers=headers)
            r.raise_for_status()
            return BeautifulSoup(r.text, features="lxml")
        except:
            return None

    @classmethod
    def get_nearest(cls, soup: BeautifulSoup) -> Optional[str]:
        # Bail out if the band is not touring
        if soup.find("div", class_="off-tour-button") is not None:
            return None

        # Get the nearest concert link
        nearest = soup.find("a", class_="see-nearest-concert-link")
        if not nearest or not nearest.get("href"):
            return None

        # Get and return the soup for this concert
        return cls._get_soup(f"{BASE_URL}/{nearest['href']}")

    @classmethod
    def from_artist_code(cls, code: str) -> Optional[Concert]:
        # Get the calendar page
        soup = cls._get_soup(f"{BASE_URL}/artists/{code}/calendar")
        if soup is None:
            return

        # Get the nearest concert
        nearest = Concert.get_nearest(soup)
        if nearest is None:
            return

        # Get the name
        name = soup.find("h1", class_="title-copy").text.split(" tour date")[-2]

        # Get the concert date, location and venue
        loc_txt  = nearest.find_all("span", class_="venue-text")
        date     = nearest.find("div", class_="event-date").text.strip()
        venue    = loc_txt[0].text.strip()
        location = loc_txt[1].find_all("span")[-1].text.strip()

        # For multiday festivals, use the start of the festival as the date and
        # parse it as a date object
        date = date.split(' – ')[0]
        date = datetime.strptime(date, "%A %d %B %Y").date()

        return cls(name, date, venue, location)

if __name__ == "__main__":
    # Make the preferred locations lowercase
    preferred = tuple(i.lower() for i in PREFERRED_LOCATIONS)

    # Scrape everything in parallel
    pool = ThreadPoolExecutor(max_workers=len(ARTISTS))
    concerts = [i for i in pool.map(Concert.from_artist_code, ARTISTS)
                if i and i.date >= datetime.today().date()]

    # Sort the concerts by their date
    concerts.sort(key=lambda concert: concert.date)

    # ANSI colors
    RESET   = "\033[0m"
    CYAN    = "\033[36m"
    RED     = "\033[31m"
    YELLOW  = "\033[33m"
    MAGENTA = "\033[35m"

    end = f" {YELLOW}┆ "

    # Print the concerts out
    for c in concerts:
        x = f"{RED}" if c.location.lower().endswith(preferred) else f"{YELLOW}"
        print(f"{x}{c.date.isoformat()}{RESET}", end=end)
        print(f"{RESET}{c.band}", end=end)
        print(f"{MAGENTA}{c.location}", end=end)
        print(f"{CYAN}{c.venue}")

    print(f"{RESET}", end='')
