#!/usr/bin/env python

from __future__ import annotations
from dataclasses import dataclass
from typing import Optional
from datetime import datetime, date
from concurrent.futures import ThreadPoolExecutor
from bs4 import BeautifulSoup
from requests import get

ARTISTS = [
    "3768296-rum-jungle",
    "590705-bon-iver",
    "4126816-wolf-alice",
    "9329894-queens-pleasure",
    "5806184-jeff-rosenstock",
    "8959074-tamino",
    "605621-tom-rosenthal",
    "10098289-ichiko-aoba",
    "383629-balthazar",
    "496602-sigur-ros",
    "1167694-shakey-graves",
    "590465-olafur-arnalds",
    "715080-warpaint",
    "542593-jose-gonzalez",
    "592267-fleet-foxes",
    "113970-iron-and-wine",
    "7858599-rainbow-kitten-surprise",
    "9582179-momma",
    "9693119-black-country-new-road",
    "9278794-black-midi",
    "10341381-geordie-greep",
    "535518-modest-mouse",
    "118509-sufjan-stevens",
    "277989-sunny-day-real-estate",
    "385433-hum",
    "1706007-pygmy-lush",
    "421785-toe",
    "1667252-enumclaw",
    "10370116-racing-mount-pleasant",
    "8663139-haley-heynderickx",
    "2739046-mouse-on-the-keys",
    "464566-do-make-say-think",
    "9377124-sorry",
    "10234682-new-eves",
]

BASE_URL = "https://www.songkick.com"

@dataclass
class Concert:
    band: str
    date: date
    venue: str
    location: str

    @staticmethod
    def _get_soup(url: str) -> Optional[BeautifulSoup]:
        try:
            r = get(url, headers={ "User-Agent": "Mozilla/5.0" })
            r.raise_for_status()
            return BeautifulSoup(r.text, features="lxml")
        except:
            return None

    @classmethod
    def get_nearest(cls, soup: BeautifulSoup) -> Optional[str]:
        # Bail out if the band is not touring
        if soup.find("div", class_="off-tour-button") is not None:
            return None

        # Get the nearest concert link
        nearest = soup.find("a", class_="see-nearest-concert-link")
        if not nearest or not nearest.get("href"):
            return None

        # Get and return the soup for this concert
        return cls._get_soup(f"{BASE_URL}/{nearest['href']}")

    @classmethod
    def from_artist_code(cls, code: str) -> Optional[Concert]:
        # Get the calendar page
        soup = cls._get_soup(f"{BASE_URL}/artists/{code}/calendar")
        if soup is None:
            return

        # Get the nearest concert
        nearest = Concert.get_nearest(soup)
        if nearest is None:
            return

        # Get the name
        name = soup.find("h1", class_="title-copy").text.split(" tour date")[-2]

        # Get the concert date, location and venue
        loc_txt  = nearest.find_all("span", class_="venue-text")
        date     = nearest.find("div", class_="event-date").text.strip()
        venue    = loc_txt[0].text.strip()
        location = loc_txt[1].find_all("span")[-1].text.strip()

        # Parse the date as a date object
        date = datetime.strptime(date, "%A %d %B %Y").date()

        return cls(name, date, venue, location)

if __name__ == "__main__":
    # Scrape everything in parallel
    pool = ThreadPoolExecutor(max_workers=len(ARTISTS))
    concerts = [i for i in pool.map(Concert.from_artist_code, ARTISTS)
                if i and i.date >= datetime.today().date()]

    # Sort the concerts by their date
    concerts.sort(key=lambda concert: concert.date)

    # ANSI colors
    RESET   = "\033[0m"
    BOLD    = "\033[1m"
    CYAN    = "\033[36m"
    YELLOW  = "\033[33m"
    MAGENTA = "\033[35m"
    GREEN   = "\033[32m"

    # Print them out
    for c in concerts:
        print(f"{RESET}{c.band}")
        print(f" {YELLOW}├ {MAGENTA}{c.location}{RESET}, {CYAN}{c.venue}")
        print(f" {YELLOW}└ {GREEN}{c.date.isoformat()}")
